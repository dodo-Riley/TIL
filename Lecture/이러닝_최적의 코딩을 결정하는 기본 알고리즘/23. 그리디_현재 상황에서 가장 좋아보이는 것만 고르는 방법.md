# 23. 그리디 : 현재 상황에서 가장 좋아보이는 것만 고르는 방법

- 그리디 알고리즘(탐욕법)
    - 현재 상황에서 지금 당장 좋은 것만 고르는 방법
    - 단순히 가장 좋아 보이는 것을 반복적으로 선택해도 최적의 해를 구할 수 있는지, 정당성 분석이 중요
    
- 거스름 돈 문제
    - 10, 50, 100, 500원짜리 동전이 무한히 존재
    - 거스름돈이 N원일 때, 거슬러주어야할 최소한의 동전 개수 구하기
    - 단, N은 항상 10의 배수
    - 해결 아이디어
        - 가장 큰 화폐 단위부터 돈을 거슬러 주면 됨
        - 1260원일 경우, 500원 2개, 100원 2개, 50원 1개, 10원 1개
        - 큰 단위가 항상 작은 단위의 배수이므로 작은 단위의 동전들을 종합해 다른 해가 나올수 없기 떄문에 최적의 해를 보장
        
        ```python
        n = 1260
        count = 0
        
        # 큰 단위의 화폐부터 차례대로 확인하기
        array = [500, 100, 50, 10]
        
        for coin in array:
        	count += n // coin # 해당 화폐로 거슬러 줄 수 있는 동전 갯수 세기
        	n %= coin
        
        print(count)
        ```
        
- 1이 될 때까지 문제
    - 어떤 수 N이 1이 될 때까지 두 가지 중 하나를 반복적으로 선택 수행
        - N에서 1을 뺀다.
        - N을 K로 나눈다.(나머지가 0일때만 수행 가능)
    - N과 K가 주어질 때, N이 1이 될때까지 과정을 수행해야 하는 최소 횟수 구하기
    - 해결 아이디어
        - 나누는 작업이 최대일 때가 전체 수행의 횟수는 가장 적음
        
        ```python
        n,k = map(int, input().split())
        
        result = 0
        
        while True:
        	# n이 k로 나누어 떨어지는 수가 될 때까지 빼기
        	target = (n//k)*k
        	result += (n-target)
        	n = target
        	# n이 k보다 작을때 반복문 탈출
        	if n<k:
        		break
        	# k로 나누기
        	result += 1
        	n //= k
        
        # 마지막으로 남은 수에 대해 1씩 빼기
        result += (n-1)
        print(result)
        ```
        
- 곱하기 혹은 더하기 문제
    - 각 자리의 숫자가 0부터 9까지 중 하나인 문자열 S가 존재
    - 각 숫자 사이에 곱하기나 더하기를 넣어서 결과적으로 만들어질 수 있는 가장 큰 수 찾기
    - 단 모든 연산은 왼쪽부터 차례대로 진행(기본적인 연산에서 곱셈 우선과는 다름)
    - 해결 아이디어
        - 기본적으로 곱하기의 결과가 더 큼
        - 단, 숫자가 0이나 1일 경우에는 더하기가 더 큼
        - 따라서 두 수중에서 하나라도 1이하인 경우에는 더하고, 나머지는 곱하면 됨
        
        ```python
        data = input()
        
        # 첫 번째 문자를 숫자로 변경하여 대입
        result = int(data[0])
        
        for i in range(1,len(data)):
        	# 두 수 중에서 하나라도 0 혹은 1인 경우, 더하기 수행
        	num = int(data[i])
        	if num <= 1 or result <= 1:
        		result += num
        	else:
        		result *= num
        
        print(result)
        ```
        
- 모험가 길드 문제
    - 모험가 N명 존재
    - 공포도가 X인 모험가는 반드시 X명 이상으로 구성한 모험가 그룹에 참여해야함
    - 여행을 떠날 수 있는 최대 그룹 수 찾기
    - 해결 아이디어
        - 오름차순 정렬 이후 공포도가 가장 낮은 모험가부터 확인
        - 현재 그룹에 포함된 모험가의 수가 현재 확인하고 있는 공포도보다 크거나 같다면 이를 그룹으로 설정
        
        ```python
        n = int(input())
        data = list(map(int, input().split()))
        data.sort()
        
        result = 0 # 총 그룹의 수
        count = 0 # 현재 그룹에 포함된 모험가의 수
        
        for i in data: # 오름차순이므로 공포도 낮은 순으로 확인하며
        	count += 1 # 현재 그룹에 해당 모험가 포함시키기
        	if count >= i: # 현재 그룹에 포함된 모험가의 수가 현재 공포도 이상이라면, 그룹 생성
        		result += 1 # 총 그룹의 수 증가
        		count = 0# 현재 그룹에 포함된 모험가 수 초기화
        
        print(result)
        ```