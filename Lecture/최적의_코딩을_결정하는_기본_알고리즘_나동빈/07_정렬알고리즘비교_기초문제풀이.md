# 7. 정렬 알고리즘 비교 및 기초 문제 풀이

- 정렬 알고리즘 비교
    
    
    | 정렬 알고리즘 | 평균 시간 복잡도 | 공간 복잡도 | 특징 |
    | --- | --- | --- | --- |
    | 선택 정렬 | O(N^2) | O(N) | 아이디어가 매우 간단 |
    | 삽입 정렬 | O(N^2) | O(N) | 데이터가 거의 정렬되어 있을 때는 가장 빠름 |
    | 퀵 정렬 | O(NlogN) | O(N) | 대부분의 경우에 가장 적합하며, 충분히 빠름 |
    | 계수 정렬 | O(N+K) | O(N+K) | 데이터의 크기가 한정되어 있는 경우에만 사용이 가능하지만 매우 빠르게 동작 |
    
- 문제
    - 두 배열의 원소 교체
        - 두 개의 배열 A와 B를 가지고 있습니다. 두 배열은 N개의 원소로 구성되어 있으며, 배열의 원소는 모두 자연수입니다.
        - 최대 K번의 바꿔치기 연산을 수행할 수 있는데, 바꿔치기 연산이란 배열 A에 있는 원소 하나와 배열 B에 있는 원소 하나를 골라서 두 원소를 서로 바꾸는 것을 말합니다.
        - 최종 목표는 배열 A의 모든 원소의 합이 최대가 되도록 하는 것입니다.
        - N, K, 그리고 배열 A와 B의 정보가 주어졌을 때, 최대 K번의 바꿔치기 연산을 수행하여 만들 수 있는 배열 A의 모든 원소의 합의 최댓값을 출력하는 프로그램을 작성하시오.
        
        ```python
        n,k = map(int, input().split()) # N, K 입력
        a = list(map(int, input().split())) # A 배열 입력
        b = list(map(int, input().split())) # B 배열 입력
        
        a.sort() # A는 오름차수 정렬
        b.sort(reverse=True) # B는 내림차순 정렬
        
        # 첫 번째 인덱스부터 확인하며, 두 배열의 원소를 최대 K번 비교
        for i in range(k):
        	if a[i]<b[i]:
        		a[i], b[i] = b[i],a[i] # A의 원소가 b의 원소보다 작을 경우, 교체
        	else:
        		break # 아니면 중단
        
        print(sum(a)) # A의 합 출력
        ```