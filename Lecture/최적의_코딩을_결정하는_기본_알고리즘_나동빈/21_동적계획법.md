# 21. 동적 계획법 : 메모리를 더 소모하여 속도를 비약적으로 향상시키는 기법

- 동적 계획법(다이나믹 프로그래밍)
    - 메모리를 적절히 사용하여 수행 시간 효율성을 비약적으로 향상시키는 방법
    - 이미 계산된 결과는 별도의 메모리 영역에 저장하여 다시 계산하지 않도록 함
    - 일반적으로 탑다운(하향식)과 바텀업(상향식)으로 구성
    - 일반적인 프로그래밍 분야에서의 동적과는 다른 의미
        - 일반적인 프로그래밍 분야에서 동적이란 ‘프로그램이 실행되는 도중에’라는 의미
        - 자료구조에서 동적 할당(dynamic allocation)은 ‘프로그램이 실행되는 도중에 실행에 필요한 메모리를 할당하는 기법’을 의미
    - 문제가 다음의 조건을 만족할 때 사용 가능
        - 최적 부분 구조(optimal substructure) : 큰 문제를 작은 문제로 나눌 수 있으며, 작은 문제의 답을 모아서 큰 문제를 해결
        - 중복되는 부분 문제(overlapping subproblem) : 동일한 작은 문제를 반복적으로 해결
    
- 피보나치 수열
    - 특정 번째 항은 그 이전과 이전의 이전 항의 합으로 구성
    
    ```python
    def fibo(x):
    	if x==1 or x==2:
    		return 1
    	return fibo(x-1)+fibo(x-2)
    
    print(fibo(4))
    ```
    
    - 시간 복잡도는 $O(2^N)$
    
- 메모이제이션(memoization)
    - 다이나믹 프로그래밍을 구현하는 방법 중 하나
    - 한 번 계산한 결과를 메모리 공간에 메모하는 기법
    - 같은 문제를 다시 호출하면 메모했던 결과를 그대로 가져옴
    - 값을 기록해 놓는다는 점에서 캐싱(caching)이라고도 함
    - 탑다운 방식
    - 결과 저장용 리스트는 DP 테이블이라고 부름
    - 엄밀히 말하면 이전에 계산도니 결과를 일시적으로 기록해 놓은 넓은 개념을 의미로, 다이나믹 프로그래밍에 국한된 개념은 아님
    - 이를 활용한 피보나치 수열
        
        ```python
        d = [0]*100 # 계산된 결과를 메모이제이션하기 위한 리스트 초기화
        
        def fibo(x):
        	if x==1 or x==2:
        		return 1 # 종료 조건
        	if d[x] !=0:
        		return d[x] # 이미 계산한 적 있는 문제라면 그대로 반환
        	d[x] = fibo(x-1)+fibo(x-2) # 아직 계산 전이면 계산 결과 반환
        	return d[x]
        
        print(fibo(99))
        ```
        
    - 바텀업 방식을 사용한 피보나치 수열
        
        ```python
        d = [0]*100 # DP테이블 초기화
        
        d[1] = 1
        d[2] = 1
        n = 99
        
        for i in range(3,n+1):
        	d[i] = d[i-1]+d[i-2]
        
        print(d[n])
        ```
        
    
- 다이나믹 프로그래밍 VS 분할 정복
    - 모두 최적 부분 구조를 가질 때 사용 가능
        - 큰 문제를 작은 문제로 나눌 수 있으며, 작은 문제의 답을 모아서 큰 문제를 해결할 수 있는 상황
    - 차이점은 부분문제의 중복
        - 다이나믹 프로그래밍에서는 각 부분 문제들이 서로 영향을 미치며 부분 문제가 중복
        - 분할 정복 문제에서는 동일한 부분 문제가 반복적으로 계산되지 않음