# 3.1.1. R 기초

## 1) 분석 환경의 이해

- R의 역사
    - 미국 벨 연구소의 John Chamber가 개발한 S언어 기반
    - 뉴질랜드 오클랜드 대학교 로스 이하카와 로버트 젠트맨에 의해 개발
    - 2000년 최초 1 버전을 시작으로 버전업 진행 중(현재 4 버전)

- R의 특징
    - 오픈 소스
    - txt, csv, 엑셀, SAS, SPSS, Stata, DB 등 다양한 데이터를 읽어오는 기능이 있어 데이터 핸들링이 우수
    - 인터프리터 언어
    - 2D, 3D, 동적 그래프를 지원하는 우수한 그래픽 기능
    - 다양한 형태의 데이터 구조(벡터, 행렬, 데이터 프레임, 리스트)를 지원하므로 분석 대응력 우수
    - 데이터는 메모리에서 작동하기 때문에 속도 우수
    

## 2) R 언어와 문법

- R의 기초
    - 연산 우선순위는 괄호 > 거듭제곱 > 곱셈/나눗셈 > 덧셈/뺄셈
    - 출력결과에 [1]이 항상 표현되고, 이는 출력물인 데이터에 대한 인덱스로 결과의 자릿수를 확인할 수 있음
    - 대소문자 구분
    - 명령어가 길 경우, `>`대신 `+`가 표시됨
    - 변수의 이름은 알파벳으로 시작해야 하며, 알파벳과 숫자, `_`와 `.`를 사용 가능
    - `install.packages(”패키지명”)`으로 패키지 설치 가능
    - `library()`, `require()`를 통해 패키지 구동
    
    ```r
    > 1+2
    [1] 3
    > 3-1
    [1] 2
    > 2*2
    [1] 4
    > 4/2
    [1] 2
    > 3^3
    [1] 27
    > 1+2;3+4
    [1] 3
    [1] 7
    > x=1;y=1;x+y
    [1] 2
    ```
    
- 할당 연산자
    - 변수나 객체에 값을 정의
    - `=`, `<-` 를 사용

- 비교 연산자
    - 데이터 간의 비교를 통해 참/거짓을 반환
    - `==` : 같음, `!` : 부정, `<,>` : 대소
    
- 논리 연산자
    - 여러 조건을 비교하여 결과 반환
    - `&` : 조건을 동시에 만족할 때 참 반환, `|` : 하나라도 만족할 때 참 반환
    

## 3) R의 데이터 구조

- 특수 형태
    - `NULL` : 비어있는 값으로 데이터 유형도 없으며 자료의 길이도 0
    - `NA` : 결측값(missing value)
    - `NaN` : 수학적으로 정의가 불가능한 수
    
- 벡터
    - 하나의 스칼라 값, 혹은 하나 이상의 스칼라 원소들을 갖는 단순한 형태의 집합
    - 벡터 데이터 내에 들어갈 수 있는 원소는 숫자, 문자, 논리연산자이며, 동일한 자료형을 갖는 값들의 집합
    - 벡터 생성함수는 아래와 같다.
      
        ```r
        # 1) c() 함수
        # 나열된 데이터나 객체들을 하나의 객체로 결합하는 함수
        # 각 원소는 ,로 구분
        > c(1,2,3)+2
        [1] 3 4 5
        > c(1,2,3)+c(4,5,6)
        [1] 5 7 9
        > c(1,2,3)+c(4,5,6,7)
        [1] 5 7 9 8
        Warning message:
        In c(1, 2, 3) + c(4, 5, 6, 7) :
          longer object length is not a multiple of shorter object length
        # 재사용 규칙 : 길이가 다른 벡터는 짧은 쪽을 처음으로 다시 적용
        # 서로 다른 유형의 데이터를 섞어서 저장하면, 한 가지 타입으로 자동 변환된다.
        
        # 2) :
        # 단위가 1인 등차ㅅ열을 나타내고자 할때 사용
        > 1:5
        [1] 1 2 3 4 5
        > 6:9
        [1] 6 7 8 9
        
        # 3) seq()
        # 단위에 관계없이 모든 등차수열을 나타낼 수 있음
        > seq(5)
        [1] 1 2 3 4 5
        > seq(1,5)
        [1] 1 2 3 4 5
        > seq(1,2,0.1)
         [1] 1.0 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 2.0
        > seq(5,1)
        [1] 5 4 3 2 1
        
        # 4) rep()
        # 주어진 벡터 객체를 반복하여 자료를 생성
        > rep(1,3)
        [1] 1 1 1
        > rep(c(1,2,3), times=2, each=2) # 각 요소를 2번씩 총 2번 반복
         [1] 1 1 2 2 3 3 1 1 2 2 3 3
        > rep(c(1,2,3),c(1,2,3)) # 각 요소를 뒤에 벡터의 요소만큼 반복
        [1] 1 2 2 3 3 3
        > rep(1:5, times=2, each=2, length.out=5) # 길이 설정
        [1] 1 1 2 2 3
        # 디폴트는 rep(x, times, length.out, each)
        
        # 5) sequence()
        # 주어진 벡터의 각 요소에 seq() 함수를 수행
        > sequence(3)
        [1] 1 2 3
        > sequence(1:5)
         [1] 1 1 2 1 2 3 1 2 3 4 1 2 3 4 5
        > sequence(c(1,5,3))
        [1] 1 1 2 3 4 5 1 2 3
        ```
        
    - 기타 유용한 함수
      
      
        | 함수 | 기능 | 함수 | 기능 |
        | --- | --- | --- | --- |
        | sum() | 합 | prod() | 곱 |
        | max() | 최대값 | min() | 최소값 |
        | which.max() | 최대값 인덱스 | which.min() | 최소값 인덱스 |
        | range() | c(min(),max()) | var() | 분산 |
        | sd() | 표준편자 | cor() | 상관계수 |
        | length() | 원소의 수 | mean() | 평균 |
        | median() | 중위수 | rev() | 원소의 역순 |
        | scale() | 표준화 | cumsum() | 누적 합 |
        | cumprod() | 누적 곱 | cummin() | 누적 최소값 |
        | cummax() | 누적 최대값 | subset() | 원소의 일부 선택 |
        | sample() | 복원/비복원의 임의 추출 | match() | 일치하는 원소의 인덱스 |
        | which() | 조건을 만족하는 원소의 인덱스 | gl() | 주어진 수준에 따른 요인 생성 |
        | dif() | 데이터 원소 사이의 차 | rank() | 순위 |
        | sort() | 정렬 | order() | rank에 해당하는 인덱스 |
        | toupper() | 대문자로 변환 | tolower() | 소문자로 변환 |
        | nchar() | 문자 길이 | substr() | 문자 일부분을 선택 혹은 변경 |
    
- 행렬
    - 행렬 정의와 같이 행*열의 수가 지정된 구조
    - 한 가지 유형의 스칼라만 사용 가능
    - 행렬 생성 함수는 아래와 같다.
      
        ```r
        > m = matrix(c(1,2,3,4,5,6), # 사용할 데이터
        							nrow=3, # 행의 수
        							ncol=2, # 열의 수
        							byrow=FALSE, # 열 우선으로 값들을 채움
        							dimnames=NULL) # 인덱스명
        > m
             [,1] [,2]
        [1,]    1    4
        [2,]    2    5
        [3,]    3    6
        > dimnames(m) = list(c('r1','r2','r3'),c('c1','c2')) # 인덱스명 설정
        > m
           c1 c2
        r1  1  4
        r2  2  5
        r3  3  6
        > a=c(10,10)
        > b=c(10,10,10)
        > rbind(m,a) # 행 추가
           c1 c2
        r1  1  4
        r2  2  5
        r3  3  6
        a  10 10
        > cbind(m,b) # 열 추가
           c1 c2  b
        r1  1  4 10
        r2  2  5 10
        r3  3  6 10
        ```
    
- 데이터 프레임
    - 행렬과 유사한 2차원 데이터 구조
    - 행렬과 달리, 각 열이 서로 다른 데이터 타입을 가질 수 있음
    - 데이터 프레임에 들어갈 벡터들의 길이가 반드시 같아야만 한다.
      
        ```r
        > a=c(1,2,3)
        > b=c('a','b','c')
        > c=c(TRUE, FALSE, FALSE)
        > df=data.frame(first=a,second=b,third=c)
        > df
          first second third
        1     1      a  TRUE
        2     2      b FALSE
        3     3      c FALSE
        ```
    
- 배열(array)
    - 행렬이 2차원 데이터라면, 배열은 다차원 데이터
    - 단일 형태의 데이터만 가능
      
        ```r
        > array(1:12,dim=c(3,4)) # dim 옵션에 차원 정보 입력
             [,1] [,2] [,3] [,4]
        [1,]    1    4    7   10
        [2,]    2    5    8   11
        [3,]    3    6    9   12
        
        > array(1:12,dim=c(2,2,3))
        , , 1
        
             [,1] [,2]
        [1,]    1    3
        [2,]    2    4
        
        , , 2
        
             [,1] [,2]
        [1,]    5    7
        [2,]    6    8
        
        , , 3
        
             [,1] [,2]
        [1,]    9   11
        [2,]   10   12
        ```
    
- 리스트
    - `(key, value)` 형태의 데이터를 담는 연관 배열
    - 서로 다른 데이터 유형을 담을 수 있음
      
        ```r
        > x=list(name='riley', tel='3333-3333')
        > x
        $name
        [1] "riley"
        
        $tel
        [1] "3333-3333"
        ```
        

## 4) 외부 데이터 불러오기

```r
# csv 파일
read.csv('파일 경로', header=T) # 헤더 옵션을 통해 파일의 첫 줄을 변수명으로 지정

# txt 파일
read.table('파일 경로', header=T, Sep=':') # 구분기호 옵션

# 엑셀 파일
# RODBC 패키지 이용 or csv로 따로 저장해 csv 파일을 불러온다.
install.packages('RODBC')
library(RODBC)
new=odbcConnectExcel('파일경로')
data=sqlFetch(nes,'파일명')
data
```

## 5) R의 기초 함수

- 수열 생성
  
    ```r
    > rep(1,3) # 1을 3번 반복
    [1] 1 1 1
    > seq(1,3) # 1부터 3까지 공차가 1인 등차수열 생성
    [1] 1 2 3
    > seq(1,11,2) # 1부터 11까지 공차가 2인 등차수열 생성
    [1]  1  3  5  7  9 11
    > seq(1,10,length=8) # 1부터 10까지를 8개로 나눈 수열 생성
    [1]  1.000000  2.285714  3.571429  4.857143
    [5]  6.142857  7.428571  8.714286 10.000000
    ```
    
- 기초적인 행렬 계산
  
    ```r
    > a=1:5
    > a+a
    [1]  2  4  6  8 10
    > a-a
    [1] 0 0 0 0 0
    > a*a
    [1]  1  4  9 16 25
    > a/a
    [1] 1 1 1 1 1
    # 기본적으로 사직연산을 수행하기 위해서는 벡터들의 길이가 같아야함
    > a=c(1,2,3) # 행렬은 생성 시 기본적으로 열방향 우선으로 값이 채워짐
    > t(a) # 전치행렬
         [,1] [,2] [,3]
    [1,]    1    2    3
    > a%*%t(a) # 행렬곱
         [,1] [,2] [,3]
    [1,]    1    2    3
    [2,]    2    4    6
    [3,]    3    6    9
    
    > a=matrix(c(23,41,12,35,67,1,24,7,53),nrow=3)
    > solve(a) # 역행렬
                [,1]        [,2]        [,3]
    [1,] -0.35743822  0.18466969  0.13746848
    [2,]  0.21069087 -0.09389813 -0.08300555
    [3,]  0.07695411 -0.04004034 -0.01069087
    > 3*a # 스칼라곱
         [,1] [,2] [,3]
    [1,]   69  105   72
    [2,]  123  201   21
    [3,]   36    3  159
    
    > c=1:10
    > mean(c) # 평균
    [1] 5.5
    > var(c) # 분산
    [1] 9.166667
    > sd(c) # 표준편차
    [1] 3.02765
    > sum(c) # 합
    [1] 55
    > median(c) # 중위수
    [1] 5.5
    > log(c) # 자연로그값
     [1] 0.0000000 0.6931472 1.0986123 1.3862944
     [5] 1.6094379 1.7917595 1.9459101 2.0794415
     [9] 2.1972246 2.3025851
    
    > a=1:10
    > b=11:20
    > cov(a,b) # 공분산
    [1] 9.166667
    > cor(a,b) # 상관계수
    [1] 1
    > summary(a) # 최소, 최대, 중앙, 평균, 사분위수
       Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
       1.00    3.25    5.50    5.50    7.75   10.00
    ```



## 6) 데이터 핸들링

- R은 객체 지향 언어이기 때문에, 객체를 불러오거나 객체 내의 요소들을 참조하는 것이 직관적이고 간단

  ```r
  > b<-c('a','b','c')
  > b
  [1] "a" "b" "c"
  > b[2] # 2번째 요소
  [1] "b"
  > b[-3] # 3번째 요소를 빼고 나머지 요소
  [1] "a" "b"
  > b[c(1,3)] # 1, 3번째 요소
  [1] "a" "c"
  > b[1:2] # 1부터 2번쨰까지 요소
  [1] "a" "b"
  ```

- 반복문과 조건문

  ```r
  # for 반복문 : () 내의 각 요소에 대해 {} 내의 문장을 수행 
  > a<-c()
  > for(i in 1:5)
  + {a[i]=i^2}
  > a
  [1]  1  4  9 16 25
  
  # while 반복문 : () 내의 조건이 참일 때, {} 내의 문장을 수행
  > x=1
  > while(x<5)
  + {x=x+1
  + print(x)}
  [1] 2
  [1] 3
  [1] 4
  [1] 5
  
  # 조건문 : ifelse(조건, 참일 때 반환 값, 거짓일 때 반환 값)
  > gender=c('1','2','2','2','1')
  > gender=ifelse(gender=='1',T,F)
  > gender
  [1]  TRUE FALSE FALSE FALSE  TRUE
  ```

- 사용자 정의 함수

  ```r
  # function 명령어 사용
  > foruse=function(number){
  +   sum=0
  +   for(i in 1:number){
  +     sum=sum+i
  +   }
  +   print(sum)
  + }
  > foruse(6)
  [1] 21
  ```

- 기타 유용한 기능들

  ```r
  # paste : 입력받은 문자열들을 하나로 붙여준다.
  > a=1:5
  > b=c('a','b','c','d','e')
  > paste(a,b,sep='/')
  [1] "1/a" "2/b" "3/c" "4/d" "5/e"
  
  # substr : 문자를 추출한다.
  > a=c('one','two','three')
  > substr(a,1,2) # a에서 각 문자열의 1번째에서 2번쨰까지 추출
  [1] "on" "tw" "th"
  
  # as.(datatype) : 데이터 타입을 변경해준다.
  > a=c(1,2,3)
  > as.data.frame(a)
    a
  1 1
  2 2
  3 3
  > as.list(a)
  [[1]]
  [1] 1
  
  [[2]]
  [1] 2
  
  [[3]]
  [1] 3
  
  > as.matrix(a)
       [,1]
  [1,]    1
  [2,]    2
  [3,]    3
  > as.factor(a)
  [1] 1 2 3
  Levels: 1 2 3
  > as.numeric(a)
  [1] 1 2 3
  > as.character(a)
  [1] "1" "2" "3"
  > as.integer(a)
  [1] 1 2 3
  > as.logical(a)
  [1] TRUE TRUE TRUE
  
  # as.Date : 문자열을 날짜로 변환해준다.
  > as.Date('2021/01/24')
  [1] "2021-01-24"
  > as.Date('01/24/2021', format='%m/%d/%Y')
  [1] "2021-01-24"
  
  # Sys.Date() : 현재 날짜를 반환한다.
  > Sys.Date()
  [1] "2022-01-24"
  > format(Sys.Date(),'%a') # 요일
  [1] "월"
  > format(Sys.Date(),'%b') # 월
  [1] "1"
  > format(Sys.Date(),'%y') # 년도
  [1] "22"
  > format(Sys.Date(),'%Y') # 년도
  [1] "2022"
  ```

## 7) R 그래픽 기능

- 산점도 그래프

  ```r
  # plot(x축 데이터, y축 데이터)
  > math=c(95,65,80,92,60,75,88,100,75,68)
  > science=c(90,70,80,95,65,70,85,95,70,60)
  > plot(math,science)
  ```

- 산점도 행렬

  ```r
  # pairs(사용데이터, main='그래프 제목', pch=점의 모양, bg=색상)
  #> pairs(iris[1:4], main="Anderson's Iris Data--3 species",
  +       pch=21, bg=c('red','green3','blue')[unclass(iris$species)])
  ```

- 히스토그램

  ```r
  # hist(사용 데이터)
  > a=c(1,2,3,4,5,6,7,6,5,4,5,8,10,4,3,2,1)
  > hist(a)
  > hist(a, breaks=3) # 구간 수 설정
  > hist(a, probability=T) # 상대도수로 히스토그램 출력
  > hist(a, probability=T, main='test', ylim=c(0,0.2)) # 상대도수로, 제목은 'test', y축 범위는 0부터 0.2까지 표시
  ```

- boxplot

  - 데이터의 분포를 시각화
  - IQR = Q3-Q1 = 전체 데이터의 50%가 위치하는 범위
  - IQR이 클수록 분산이 크다는 의미
  - 최대값=Q3+1.5IQR
  - 최소값=Q1-1.5IQR
  - 작은 원은 이상치(outlier)
  - 사각형 내 굵은 선은 중앙값
  - boxplot()은 데이터에 NA가 있어도 실행이 됨

  ```r
  > a=c(1,2,3,4,5,6,7,6,5,4,5,8,10,4,3,2,1)
  > boxplot(a)
  ```

- mosaic plot

  - 범주형 다변량 데이터를 표현하는 데 적합한 그래프
  - 사각형들이 그래프에서 나열되며, 각 사각형의 넓이가 각 범주에 속한 데이터의 수에 해당